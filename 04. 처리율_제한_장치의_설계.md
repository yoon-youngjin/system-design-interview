## 처리율 제한 장치의 설계

네트워크 시스템에서 처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치다. 
HTTP를 예로 들면 이 장치는 특정 기간 내에 전송되는 클라이언트 요청 횟수를 제한한다. API 요청 횟수가 제한 장치에 정의된 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)된다.

- 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
- 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없다. 

**처리율 제한 장치의 장점**
- DoS(Denial of Service) 공격에 의한 자원 고갈을 방지할 수 있다. 예를 들어 트위터는 3시간 동안 300개의 트윗만 올릴 수 있도록 제한하고 있다.
- 비용을 절감한다. 추가 요청에 대한 처리를 제한하면 서버를 많이 두지 않아도 되고, 우선순위가 높은 API에 더 많은 자원을 할당할 수 있다. 
- 서버 과부화를 막는다. 봇(bot)에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는데 처리율 제한 장치를 활용할 수 있다.

### [1단계] 문제 이해 및 설계 범위 확정

#### 면접관과 소통하여 얻어낸 정보

- 서버측 API를 위한 제한 장치
- 다양한 형태의 제어 규칙을 정의할 수 있도록 하는 유연한 시스템 -> IP 주소, 사용자 ID, ...
- 대규모 요청을 처리할 수 있어야 함
- 분산 환경에서 동작
- 처리율 제한 장치는 독립된 서비스 or 애플리케이션 코드에 포함 
- 처리율 제한 장치에 의해 걸러진 경우 사용자에게 그 사실을 알려야 한다.

#### 요구사항

- 설정된 처리율을 초과하는 요청은 정확하게 제한한다.
- 낮은 응답시간 : 이 처리율 제한 장치는 HTTP 응답시간에 나쁜 영향을 주어서는 곤란한다.
- 가능한 한 적은 메모리를 써야 한다.
- 분산형 처리올 제한(distributed rate limiting) : 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야 한다.
- 예외 처리 : 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다.
- 높은 결함 감내성(fault tolerance) : 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안 된다.

### [2단계] 개략적 설계안 제시 및 동의 구하기 

#### 처리율 제한 장치는 어디에 둘 것인가?

- 클라이언트 측 : 일반적으로 클라이언트는 처리율 제한을 안정적으로 걸 수 있는 장소가 못 된다. 클라이언트 요청은 쉽게 위변조가 가능해서다. 

![image](https://user-images.githubusercontent.com/83503188/235617932-ff3ac374-fd27-43b9-bc55-c07975b36bba.png)
- 서버 측 

![image](https://user-images.githubusercontent.com/83503188/235617968-b96472ba-4f1e-4e3a-926e-e115bd1afdb4.png)
- 별도의 처리율 제한 미들웨어

클라우드 마이크로서비스의 경우, 처리율 제한 장치는 보통 API 게이트웨이라 불리는 컴포넌트에 구현된다. API 게이트웨이는 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리 등을 지원하는 완전 위탁관리형 서비스, 즉 클라우드 업체가 유지 보수를 담당하는 서비스이다.
하지만 일단 API 게이트웨이가 처리율 제한을 지원하는 미들웨어라는 점만 기억하도록 하자.

#### 정리
- 프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술 스택을 점검하라. 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기 충분할 정도로 효율이 높은지 확인하라.
- 사업 필요에 맞는 처리율 제한 알고리즘을 찾아라. 서버 측에서 모든 것을 구현하기로 했다면, 알고리즘을 자유롭게 선택할 수 있지만 제3 사업자가 제공하는 게이트웨이를 사용하기로 했다면 선택지는 제한될 수 있다.
- MSA에 기반하고 있고, 사용자 인증이나 IP 허용목록 관리 등을 처리하기 위해 API 게이트웨이를 이미 설계에 포함시켰다면 처리율 제한 기능 또한 게이트웨이에 포함시켜야 할 수도 있다.
- 처리율 제한 서비스를 직접 만드는 데는 시간이 든다. 처리율 제한 장치를 구현하기에 충분한 인력이 없다면 상용 API 게이트웨이를 쓰는 것이 바람직하다. 

#### 처리율 제한 알고리즘
- 토큰 버킷(token bucket)
- 누출 버킷(leaky bucket)
- 고정 윈도 카운터(fixed window counter)
- 이동 윈도 로그(sliding window log)
- 이동 윈도 카운터(sliding window counter)

**토큰 버킷 알고리즘**

토큰 버킷은 지정된 용량을 갖는 컨테이너다. 이 버킷에는 사전 설정된 양의 토큰이 주기적으로 채워진다. 토큰이 꽉 찬 버킷에는 더 이상의 토큰은 추가되지 않는다. 

![image](https://user-images.githubusercontent.com/83503188/235623563-42a5d552-1f97-4f3b-8fdc-abad8868f819.png)
- 사용자마다 버킷을 부여한다.
- 위의 예제에서 토큰 공급기(refiler)는 버킷에 매초 2개의 토큰을 추가한다. 버킷이 가능 차면 추가로 공급된 토큰은 버려진다.(overflow)

![image](https://user-images.githubusercontent.com/83503188/235624205-3088d016-84dd-43eb-9b92-bc989a82646c.png)
- 각 요청은 처리될 때마다 하나의 토큰을 사용한다. 요청이 도착하면 버킷에 충분한 토큰이 있는지 검사하게 된다. 
  - 충분한 토큰이 있는 경우 : 버킷에서 토큰을 하나 꺼낸 후 요청을 시스템에 전달한다.
  - 충분한 토큰이 없는 경우 : 해당 요청은 버려진다.(dropped)

**개략적인 아키텍처**

얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고(사용자별로 추적할 것인가? IP 주소별로? API 엔드포인트나 서비스 단위로?), 이 카운터의 값이 어떤 한도를 넘어서면 한도를 넘어 도착한 요청은 거부하는 것이다.
그렇다면 이 카운터는 어디 보관할 것인가? DB는 디스크 접근 때문에 느리니까 사용하면 안될 것이다. 메모리상에서 동작하는 캐시가 바람직한데, 빠른데다 시간에 기반한 만료 정책을 지원하기 때문이다. 

![image](https://user-images.githubusercontent.com/83503188/235665367-4ee50c5b-ca32-42dd-b147-c42fc3ca6b17.png)
- 클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.
- 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와서 한도에 도달했는지 아닌지를 검사한다.
  - 한도에 도달했다면 요청은 거부된다.
  - 한도에 도달하지 않았다면 요청은 API 서버로 전달된다. 한편 미들웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장한다.

### [3단계] 상세 설계

추가적인 사항 

- 처리율 제한 규칙은 어떻게 만들어지고 어디에 저장되는가?
- 처리가 제한된 요청들은 어떻게 처리되는가?

#### 처리율 제한 규칙

**처리율 한도 초과 트래픽의 처리** 

어떤 요청이 한도 제한에 걸리면 API는 HTTP 429(too many requests)을 클라이언트에게 보낸다. 경우에 따라서는 한도 제한이 걸린 메시지를 나중에 처리하기 위해 큐에 보관할 수도 있다.

**처리율 제한 장치가 사용하는 HTTP 헤더**

클라이언트가 자기 요청이 처리율 제한에 걸리고 있는지를 감지하기 위해서 커스텀 HTTP 헤더를 사용한다.

예시
- X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청의 수
- X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
- X-Ratelimit-Retry-After: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림

![image](https://user-images.githubusercontent.com/83503188/235670088-55b2a7e9-640f-4aae-b9b4-3baf600162db.png)
- 처리율 제한 규칙은 디스크에 보관한다. 작업 프로세스(workers)는 수시로 규칙을 디스크에서 읽어 캐시에 저장한다.
- 클라이언트가 요청을 서버에 보내면 요청은 먼저 처리율 제한 미들웨어에 도달한다.
- 처리율 제한 미들웨어는 제한 규칙을 캐시에서 가져온다. 아울어 카운터 및 마지막 요청의 타임스탬프(timestamp)를 레디스 캐시에서 가져온다. 
  - 해당 요청이 처리율 제한에 걸리지 않은 경우에는 API 서버로 보낸다.
  - 해당 요청이 처리율 제한에 걸렸다면 429 too many requests 에러를 클라이언트에 보낸다. 

#### 분산 환경에서의 처리율 제한 장치의 구현

여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 또 다른 문제다. 
- 경쟁 조건(race condition) -> 분산 락 
- 동기화(synchronization) 문제 -> 중앙 집중형 데이터 저장소
- 성능 최적화 -> 세계 곳곳에 에지 서버를 두고 사용자의 트래픽을 가장 가까운 에지 서버로 전달하여 지연시간을 줄인다.
- 모니터링
